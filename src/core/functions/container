#!/command/with-contenv bash

# Load default configurations for the container
source /config/defaults/00-container

# COLOR CONFIGURATION SETTINGS
# -----------------------------
# ANSI escape codes for background colors
bdg="\e[42m"       # Dark Green Background
bdb="\e[44m"       # Dark Blue Background
bdm="\e[45m"       # Dark Magenta Background
bdgy="\e[100m"     # Dark Gray Background
blr="\e[101m"      # Light Red Background
boff="\e[49m"      # Reset Background Color

# INITIALIZATION FUNCTIONS
# -------------------------
# Functions to initialize container and services

# Wait for container initialization to complete.
check_container_initialized() {
    # Print debug message to indicate the check has started
    print_debug "Checking to see if container initialization scripts have completed"

    # Temporarily disable output to avoid unnecessary logging
    output_off

    # Loop until the initialization marker file is found
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Waiting for container initialization to complete"
        sleep 1
    done

    # Re-enable output once the check is complete
    output_on
}

# Wait for a service or its initialization phase to complete.
check_service_initialized() {
    # Print debug message indicating the start of the service check
    print_debug "Checking if the service has been initialized"

    # Temporarily disable output to avoid unnecessary log clutter
    output_off

    # Determine service suffix and bypass mode
    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    # Determine the service name if bypass mode is FALSE
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            # Identify the service based on the script's location or current directory
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    # Wait for the marker file to appear, indicating the service has been initialized
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        sleep 1
        print_debug "Looking for /tmp/.container/${service}${service_suffix}"
    done

    # Clean up temporary variables
    unset csi_bypass

    # Re-enable output
    output_on
}

# SERVICE MANAGEMENT FUNCTIONS
# -----------------------------
# Functions for managing services

# Load service-specific configurations and functions.
prepare_service() {
    # Print debug message to indicate the start of service preparation
    print_debug "Preparing service for execution"

    # If a parameter is provided, handle specific cases
    if [ -n "$1" ]; then
        case "$(dirname "$0")" in
            # For container initialization scripts
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
                ;;
            # For other contexts, handle defaults and functions based on input
            *)
                case "$1" in
                    "BOTH" | "both" | "ALL" | "all")
                        get_defaults "$2"
                        get_functions "$2"
                        ;;
                    "DEFAULTS" | "defaults")
                        get_defaults "$2"
                        ;;
                    "FUNCTIONS" | "functions")
                        get_functions "$2"
                        ;;
                esac
                ;;
        esac
    else
        # If no parameter is provided, load defaults and functions based on context
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
                ;;
            # Default behavior: only load defaults
            *)
                get_defaults
                ;;
        esac
    fi
}

# Start a service by linking its configuration to the active services directory.
service_start() {
    if [ -z "$1" ]; then
        print_error "Service name is required to start the service."
        return 1
    fi
    print_info "Starting service: $1"
    ln -sf /etc/services.available/"${1}" /etc/services.d/
}

# Stop a service by marking it as inactive with a flag.
service_stop() {
    # Validate input parameter
    if [ -z "$1" ]; then
        print_error "Service name is required to stop the service."
        return 1
    fi

    # Append a marker to indicate the service should not start
    print_info "Stopping service: $1"
    echo "DONOTSTART added by $(basename "$0")" >> /tmp/.container/"${1}"-init
}

# CUSTOMIZATION FUNCTIONS
# ------------------------
# Functions to handle custom scripts and files

# Copy custom files from source to destination with optional ownership change.
custom_files() {
    # Determine source and destination paths
    if [ -n "$2" ]; then
        source_path="$1"
        destination_path="$2"
    else
        source_path="${CONTAINER_CUSTOM_PATH}"
        destination_path="$1"
    fi

    # Validate and copy files if the source directory exists and is not empty
    if [ -d "$source_path" ] && dir_notempty "$source_path"; then
        print_debug "Custom Files: Copying files from '$source_path' to '$destination_path'"

        # Ensure the destination directory exists
        if [ ! -d "$destination_path" ]; then
            mkdir -p "$destination_path"
        fi

        # Copy files recursively while preserving attributes
        cp -aR "$source_path"/* "$destination_path"/
    fi

    # Handle optional user and group ownership changes
    if [ -n "$3" ] || [ -n "$4" ]; then
        ownership="$3"
        [ -n "$4" ] && ownership="$3:$4"
        chown -R "$ownership" "$destination_path"
    fi
}

# Execute custom scripts located in a specified directory or the default custom scripts path.
custom_scripts() {
    # Determine the source directory for custom scripts
    if [ -n "$1" ]; then
        script_source="$1"
    else
        script_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
    fi

    # Check if the source directory exists and is not empty
    if [ -d "$script_source" ] && dir_notempty "$script_source"; then
        # Iterate over all executable `.sh` files in the directory
        for script in "$script_source"/*.sh; do
            if [ -x "$script" ] && [ ! -d "$script" ]; then
                print_debug "Executing custom script: '${script}'"
                "$script"
            fi
        done
    fi
}

# LOGGING AND OUTPUT FUNCTIONS
# -----------------------------
# Functions for managing logs and output

# Function to create a logrotate configuration file for a specified log file.
create_logrotate() {
    # Ensure required parameters are provided
    if [ -n "$1" ] && [ -n "$2" ]; then

        # Skip if the logrotate configuration file already exists
        if [ ! -f /config/logrotate/"$1" ]; then
            print_debug "Creating Logrotate Entry for $2"

            # Optional log shipping configuration
            if [ -n "$3" ] && [ "${3,,}" != "none" ]; then
                log_ship_entry="# logship: $3"
            fi

            # Optional user and group for logrotate execution
            if [ -n "$4" ] && [ -n "$5" ]; then
                logrotate_user="    su $4 $5"
            fi

            # Ensure the logrotate directory exists
            if [ ! -d "/config/logrotate" ]; then
                mkdir -p /config/logrotate
            fi

            # Write the logrotate configuration
            cat <<EOF > /config/logrotate/"$1"
${log_ship_entry}
$2 {
    missingok
${logrotate_user}
}
EOF
            # Set appropriate ownership and permissions
            chown root:root /config/logrotate/"$1"
            chmod 0644 /config/logrotate/"$1"
        else
            print_debug "Skipping creation of logrotate entry for $1 as it already exists."
        fi
    else
        print_error "Required parameters missing. Logrotate file name and log file path are mandatory."
    fi
}

# Function to format log messages with a prefix
log_prefix() {
    # Temporarily disable output
    output_off

    # Check if log prefixing is enabled
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        # Print log prefix with date and time formats
        echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
    fi

    # Re-enable output
    output_on
}

# Disable command output tracing when debug mode is enabled
output_off() {
    # If debug mode is enabled, disable tracing with 'set +x'
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        set +x
    fi
}

# Enable command output tracing when debug mode is enabled
output_on() {
    # Check if debug mode is enabled
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        # Handle cases based on script name or directory context
        case "$(basename "$0")" in
            0*-* | 99-* )
                # Skip tracing for initialization or finalization scripts
                :
                ;;
            run )
                # For scripts named 'run', further check the directory context
                case "$PWD" in
                    */0*-* | 99-* )
                        # Skip tracing for certain directory contexts
                        :
                        ;;
                    * )
                        # Enable tracing for all other cases
                        set -x
                        ;;
                esac
                ;;
            * )
                # Enable tracing for all other scripts
                set -x
                ;;
        esac
    fi
}
