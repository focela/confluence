#!/command/with-contenv bash

# Load default container configuration
source /assets/defaults/00-container

# Background Colors Configuration
bdg="\e[42m"       # Background color: Dark Green
bdb="\e[44m"       # Background color: Dark Blue
bdm="\e[45m"       # Background color: Dark Magenta
bdgy="\e[100m"     # Background color: Dark Gray
blr="\e[101m"      # Background color: Light Red
boff="\e[49m"      # Reset background color to default

## Function: Checks if the container initialization scripts have completed
## Usage:
## - check_container_initialized
## Notes:
## - This function continuously checks for the presence of the initialization flag file.
## - Ensures that the container is properly initialized before proceeding with further operations.
check_container_initialized() {
    # Print a debug message to indicate the initialization check process
    print_debug "Checking if container initialization scripts have completed"

    # Disable console output during the waiting process to reduce clutter
    output_off

    # Wait until the initialization flag file is present
    while [ ! -f /tmp/.container/99-container-init ]; do
        # Print debug messages to indicate progress
        print_debug "Container initialization in progress..."
        sleep 1  # Pause for 1 second before rechecking
    done

    # Re-enable console output after the initialization process completes
    output_on
}

## Function: Checks if a service has been initialized
## Usage:
## - check_service_initialized init: Checks for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>-init.
## - check_service_initialized <service folder>: Checks for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>.
## Notes:
## - Related to the liftoff function, which writes /tmp/.container/script|foldername.
## - Scripts in /etc/cont-init.d add `-init` to their filename.
## - Scripts in /etc/services.available/* use the folder name directly without any suffix.
check_service_initialized() {
    # Print a debug message to indicate initialization check
    print_debug "Checking to see if service has initialized"

    # Disable output during the waiting process
    output_off

    # Determine service initialization behavior based on input arguments
    if [ "$1" = "init" ]; then
        # For scripts running in /etc/cont-init.d, append `-init` to the service name
        service_suffix="-init"
        csi_bypass=FALSE
    else
        # For services in /etc/services.available, use folder name directly
        service="$1"
        csi_bypass=TRUE
    fi

    # Resolve the service name if bypass is disabled
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            # Determine service name based on the script's execution context
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    # Use the script name as the service name
                    service=$(basename "$0")
                ;;
                *)
                    # Use the current working directory as the service name
                    service=$(basename "$PWD")
                ;;
            esac
        else
            # Use the second argument as the service name
            service=$2
        fi
    fi

    # Wait until the service initialization flag file is present
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        # Wait for 1 second before checking again
        sleep 1
        # Print debug message to indicate the file being checked
        print_debug "Looking for existence of /tmp/.container/${service}${service_suffix}"
    done

    # Cleanup temporary variable
    unset csi_bypass

    # Re-enable output after initialization is complete
    output_on
}

## Function: Clones a Git repository with optional branch, tag, or commit
## Usage:
## - clone_git_repo <repo_url> <branch/tag/commit> <custom_dest>
## - Example: clone_git_repo https://github.com/maintainer/repo main /custom/destination
## Notes:
## - Automatically creates a folder in `/usr/src/<repo_name>` if no custom destination is provided.
## - Exposes environment variables `GIT_REPO_SRC` and `GIT_REPO_SRC_<REPONAME>` (uppercase).
## - Removes special characters except numbers and letters in the repository name.
clone_git_repo() {
    # Temporarily disable debug output
    set +x
    if [ "${DEBUG_MODE,,}" = "true" ]; then set -x; fi  # Enable debug mode if set

    # Check if Git is installed
    if ! [ -x "$(command -v git)" ]; then
        echo '[clone_git_repo] Git is not installed'
        exit 1
    else
        git config --global init.defaultBranch main  # Set default branch to "main"
    fi

    # Validate repository URL and parameters
    if [ -n "$1" ]; then
        # Define repository path and name based on input
        if [ -n "${3}" ]; then
            repo="${3}/"
            repo_text="to '${3}'"
            repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        else
            repo="/usr/src/$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
            repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        # Export environment variables for the repository
        export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repo}"}
        export GIT_REPO_SRC_${repo_name^^}="${repo}"

        # Check if the directory already exists
        if [ -d "${repo}" ]; then
            echo "[clone_git_repo] Directory ${repo_path}${repo} already exists. Cannot clone."
            exit 1
        else
            # Append ".git" suffix if missing
            if [[ $1 == *".git" ]]; then
                append_git_prefix=""
            else
                append_git_prefix=".git"
            fi

            # Create directory, initialize, and clone the repository
            mkdir -p "${repo}"
            cd "${repo}"
            git init .
            git remote add origin "${1}${append_git_prefix}"

            # Fetch and checkout specific branch/tag/commit if provided
            if [ -n "${2}" ]; then
                repo_commit="${2}"
            fi
            echo "[clone_git_repo] Cloning Git Repo '${1}' '${2}' ${repo_text}"
            git fetch --depth=1 origin ${2} +refs/tags/*:refs/tags/*
            git fetch --depth 1 origin ${2}
            git -c advice.detachedHead=false checkout FETCH_HEAD
            git submodule update --init
        fi
    else
        # Print an error if no arguments are provided
        echo "[clone_git_repo] You tried to call the function but there's no arguments."
        exit 1
    fi

    # Re-enable debug output
    set -x
}

## Function: Creates a logrotate configuration file
## Usage:
## - create_logrotate <config_name> <path> [parser] [user] [group]
## - Example: create_logrotate cron /var/log/cron/cron.log cron root root
## Notes:
## - If no parser is provided, use 'none' as the third argument.
## - If wildcard characters (e.g., `/logs/*.log`) are passed, run `set -f` before the function and `set +f` after.
create_logrotate() {
    # Ensure required arguments are provided
    if [ -n "$1" ] && [ -n "$2" ]; then
        # Check if the logrotate configuration already exists
        if [ ! -f /assets/logrotate/"$1" ]; then
            print_debug "Creating Logrotate Entry for $2"  # Debug message for logrotate creation

            # Optional: Add logship parser configuration
            if [ -n "$3" ]; then
                if [ "${3,,}" != "none" ]; then
                    lrlsparser="# logship: $3"
                fi
            fi

            # Optional: Add user and group configuration for logrotate
            if [ -n "$4" ] && [ -n "$5" ]; then
                lruser="    su $4 $5"
            fi

            # Ensure the logrotate directory exists
            if [ ! -d "/assets/logrotate" ]; then
                mkdir -p /assets/logrotate
            fi

            # Create the logrotate configuration file
            cat <<EOF > /assets/logrotate/"${1}"
${lrlsparser}
$2 {
    missingok
${lruser}
}
EOF

            # Set appropriate permissions for the configuration file
            chown root:root /assets/logrotate/"${1}"
            chmod 0644 /assets/logrotate/"${1}"
        else
            print_debug "Skipping creating automatic logrotation for ${1}"  # Debug message if config exists
        fi
    fi
}

## Function: Creates a Zabbix auto-register configuration
## Usage:
## - create_zabbix <config_name> [autoregister_name]
## - Example: create_zabbix cron
## Notes:
## - If no autoregister name is provided, it defaults to the configuration name.
## - This function only operates if monitoring is enabled and the backend is Zabbix.
create_zabbix() {
    # Validate the required configuration name argument
    if [ -n "$1" ]; then
        # Set autoregister name to the second argument if provided; otherwise, use the config name
        if [ -n "$2" ]; then
            autoregister=$2
        else
            autoregister=$1
        fi

        # Debug message for adding Zabbix configuration
        print_debug "Adding Zabbix Auto Register configuration for '$1'"

        # Ensure monitoring is enabled and the backend is Zabbix before proceeding
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            # Load Zabbix configuration defaults
            source /assets/defaults/03-monitoring

            # Create the Zabbix configuration file
            cat <<EOF > "${ZABBIX_CONFIG_PATH}/${ZABBIX_CONFIG_FILE}.d/focela_$1.conf"
# Zabbix $1 Configuration - Automatically Generated
# Autoregister=$autoregister
EOF
        fi
    fi
}

## Function: Copies custom files from a source to a destination
## Usage:
## - custom_files <destination> [source] [user] [group]
## Notes:
## - If the source directory is omitted, it defaults to `CONTAINER_CUSTOM_PATH`.
## - Ensures the destination directory exists before copying files.
## - Optionally, changes ownership of the copied files to the specified user and group.
custom_files() {
    # Determine source and destination directories
    if [ -n "${2}" ]; then
        ccustom_files_source="${1}"
        ccustom_files_destination="${2}"
    else
        ccustom_files_source="${CONTAINER_CUSTOM_PATH}"
        ccustom_files_destination="${1}"
    fi

    # Check if the source directory exists and is not empty
    if [ -d "${ccustom_files_source}" ] && dir_notempty "${ccustom_files_source}"; then
        # Print a debug message about the copy operation
        print_debug "Custom Files: Copying files from '${ccustom_files_source}' to '${ccustom_files_destination}'"

        # Ensure the destination directory exists
        if [ ! -d "${ccustom_files_destination}" ]; then
            mkdir -p "${ccustom_files_destination}"
        fi

        # Copy files from source to destination
        cp -aR "${ccustom_files_source}"/* "${ccustom_files_destination}"/
    fi

    # Handle optional user and group ownership
    if [ -n "${3}" ]; then
        permbuilder="${3}"
    fi
    if [ -n "${4}" ]; then
        permbuilder="${3}:${4}"
    fi
    if [ -n "${permbuilder}" ]; then
        # Change ownership of the destination directory
        chown -R "${permbuilder}" "${ccustom_files_destination}"
    fi
}

## Function: Executes custom scripts from a specified directory
## Usage:
## - custom_scripts [source_directory]
## - Example: custom_scripts /path/to/scripts
## Notes:
## - If no source directory is specified, the default is `CONTAINER_CUSTOM_SCRIPTS_PATH`.
## - Only executable files with the `.sh` extension are executed.
## - Skips directories and non-executable files.
custom_scripts() {
    # Determine the source directory for custom scripts
    if [ -n "${1}" ]; then
        ccustom_scripts_source="${1}"
    else
        ccustom_scripts_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
    fi

    # Check if the source directory exists and is not empty
    if [ -d "${ccustom_scripts_source}" ] && dir_notempty "${ccustom_scripts_source}"; then
        # Iterate over each shell script in the directory
        for ccustom_script in "${ccustom_scripts_source}"/*.sh; do
            # Ensure the file is executable and not a directory
            if [ -x "$ccustom_script" ] && [ ! -d "$ccustom_script" ]; then
                # Print debug message and execute the script
                print_debug "Executing custom script: '${ccustom_script}'"
                "${ccustom_script}"
            fi
        done
    fi
}

## Function: Checks if a database service is ready
## Usage:
## - db_ready <dbtype>
## - Example: db_ready mysql
## Notes:
## - Supports multiple database types: CouchDB, InfluxDB, MongoDB, MySQL, PostgreSQL, RabbitMQ, Redis, and RethinkDB.
## - Uses environment variables (e.g., `DB_HOST`, `DB_PORT`) to determine connection details.
## - Retries the connection until the service becomes available.
db_ready() {
    # Disable output during the database readiness check
    output_off

    # Print debug message indicating the start of the check
    print_debug "Checking to see if Database Type $1 is ready"

    case "$1" in
        "couch" | "couchdb" )
            # Transform and prioritize port variables
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                couch_port=${DB_PORT}
            fi
            transform_file_var COUCHDB_PORT
            if [ -n "${COUCHDB_PORT}" ]; then
                couch_port=${COUCHDB_PORT}
            fi
            couch_port=${couch_port:-5984}

            # Transform and prioritize host variables
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                couch_host=${DB_HOST}
            fi
            transform_file_var COUCHDB_HOST
            if [ -n "${COUCHDB_HOST}" ]; then
                couch_host=${COUCHDB_HOST}
            fi
            couch_host=${couch_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until CouchDB becomes accessible
            while ! (nc -z "${couch_host}" "${couch_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "CouchDB Host '${couch_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "influx" | "influxdb" )
            # Transform and prioritize port variables
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                influx_port=${DB_PORT}
            fi
            transform_file_var INFLUXDB_PORT
            if [ -n "${INFLUXDB_PORT}" ]; then
                influx_port=${INFLUXDB_PORT}
            fi
            influx_port=${influx_port:-8088}

            # Transform and prioritize host variables
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                influx_host=${DB_HOST}
            fi
            transform_file_var INFLUXDB_HOST
            if [ -n "${INFLUXDB_HOST}" ]; then
                influx_host=${INFLUXDB_HOST}
            fi
            influx_host=${influx_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until InfluxDB becomes accessible
            while ! (nc -z "${influx_host}" "${influx_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "InfluxDB Host '${influx_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "mongo" | "mongodb" )
            # Transform and prioritize port variables
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                mongo_port=${DB_PORT}
            fi
            transform_file_var MONGO_PORT
            if [ -n "${MONGO_PORT}" ]; then
                mongo_port=${MONGO_PORT}
            fi
            mongo_port=${mongo_port:-27017}

            # Transform and prioritize host variables
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                mongo_host=${DB_HOST}
            fi
            transform_file_var MONGO_HOST
            if [ -n "${MONGO_HOST}" ]; then
                mongo_host=${MONGO_HOST}
            fi
            mongo_host=${mongo_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until MongoDB becomes accessible
            while ! (nc -z "${mongo_host}" "${mongo_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "MongoDB Host '${mongo_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "mysql" | "mariadb" | "MARIADB" | "MYSQL" )
            # Determine the appropriate client binary
            if command -v "mysqladmin" &> /dev/null; then
                mysqladmin_bin="$(which mysqladmin)"
            elif command -v "mariadb-admin" &> /dev/null; then
                mysqladmin_bin="$(which mariadb-admin)"
            else
                print_error "No MySQL or MariaDB client detected - Cannot check for Database"
                exit 1
            fi

            # Resolve port configurations
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                maria_port=${DB_PORT}
            fi
            transform_file_var MYSQL_PORT
            if [ -n "${MYSQL_PORT}" ]; then
                maria_port=${MYSQL_PORT}
            fi
            transform_file_var MARIA_PORT
            if [ -n "${MARIA_PORT}" ]; then
                maria_port=${MARIA_PORT}
            fi
            maria_port=${maria_port:-3306}

            # Resolve host configurations
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                maria_host=${DB_HOST}
            fi
            transform_file_var MYSQL_HOST
            if [ -n "${MYSQL_HOST}" ]; then
                maria_host=${MYSQL_HOST}
            fi
            transform_file_var MARIA_HOST
            if [ -n "${MARIA_HOST}" ]; then
                maria_host=${MARIA_HOST}
            fi
            maria_host=${maria_host:-"localhost"}

            # Resolve user configurations
            transform_file_var DB_USER
            if [ -n "${DB_USER}" ]; then
                maria_user=${DB_USER}
            fi
            transform_file_var MYSQL_USER
            if [ -n "${MYSQL_USER}" ]; then
                maria_user=${MYSQL_USER}
            fi
            transform_file_var MARIA_USER
            if [ -n "${MARIA_USER}" ]; then
                maria_user=${MARIA_USER}
            fi

            # Resolve password configurations
            transform_file_var DB_PASS
            if [ -n "${DB_PASS}" ]; then
                maria_pass=${DB_PASS}
            fi
            transform_file_var MYSQL_PASS
            if [ -n "${MYSQL_PASS}" ]; then
                maria_pass=${MYSQL_PASS}
            fi
            transform_file_var MARIA_PASS
            if [ -n "${MARIA_PASS}" ]; then
                maria_pass=${MARIA_PASS}
            fi

            # Resolve database name configurations
            transform_file_var DB_NAME
            if [ -n "${DB_NAME}" ]; then
                maria_name=${DB_NAME}
            fi
            transform_file_var MYSQL_NAME
            if [ -n "${MYSQL_NAME}" ]; then
                maria_name=${MYSQL_NAME}
            fi
            transform_file_var MARIA_NAME
            if [ -n "${MARIA_NAME}" ]; then
                maria_name=${MARIA_NAME}
            fi

            # Initialize retry counter
            counter=0

            # Retry until MySQL/MariaDB server becomes accessible
            while ! ("${mysqladmin_bin}" -u"${maria_user}" -P"${maria_port}" -h"${maria_host}" -p"${maria_pass}" status > /dev/null 2>&1); do
                sleep 5
                (( counter+=5 ))
                print_warn "MySQL/MariaDB Server '${maria_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        "pgsql" | "psql" | "postgres" | "postgresql" )
            # Check if the PostgreSQL client `pg_isready` is available
            if command -v "pg_isready" &> /dev/null; then
                pg_isready_bin="$(which pg_isready)"
            else
                print_error "No PostgreSQL client detected - Cannot check for Database"
                exit 1
            fi

            # Resolve port configurations
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                postgres_port=${DB_PORT}
            fi
            transform_file_var POSTGRES_PORT
            if [ -n "${POSTGRES_PORT}" ]; then
                postgres_port=${POSTGRES_PORT}
            fi
            postgres_port=${postgres_port:-5432}

            # Resolve host configurations
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                postgres_host=${DB_HOST}
            fi
            transform_file_var POSTGRES_HOST
            if [ -n "${POSTGRES_HOST}" ]; then
                postgres_host=${POSTGRES_HOST}
            fi
            postgres_host=${postgres_host:-"localhost"}

            # Resolve user configurations
            transform_file_var DB_USER
            if [ -n "${DB_USER}" ]; then
                postgres_user=${DB_USER}
            fi
            transform_file_var POSTGRES_USER
            if [ -n "${POSTGRES_USER}" ]; then
                postgres_user=${POSTGRES_USER}
            fi

            # Resolve password configurations
            transform_file_var DB_PASS
            if [ -n "${DB_PASS}" ]; then
                postgres_pass=${DB_PASS}
            fi
            transform_file_var PGPASSWORD
            if [ -n "${PGPASSWORD}" ]; then
                postgres_pass=${PGPASSWORD}
            fi

            # Resolve database name configurations
            transform_file_var DB_NAME
            if [ -n "${DB_NAME}" ]; then
                postgres_name=${DB_NAME}
            fi
            transform_file_var POSTGRES_NAME
            if [ -n "${POSTGRES_NAME}" ]; then
                postgres_name=${POSTGRES_NAME}
            fi

            # Initialize retry counter
            counter=0

            # Export password for PostgreSQL authentication
            export PGPASSWORD=${postgres_pass}

            # Retry until PostgreSQL server becomes accessible
            until "${pg_isready_bin}" --dbname="${postgres_name}" --host="${postgres_host}" --port="${postgres_port}" --username="${postgres_user}" -q; do
                sleep 5
                (( counter+=5 ))
                print_warn "PostgreSQL Host '${postgres_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        "rabbit" | "rabbitmq" )
            # Resolve port configurations
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                rabbit_port=${DB_PORT}
            fi
            transform_file_var RABBIT_PORT
            if [ -n "${RABBIT_PORT}" ]; then
                rabbit_port=${RABBIT_PORT}
            fi
            rabbit_port=${rabbit_port:-5672}

            # Resolve host configurations
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                rabbit_host=${DB_HOST}
            fi
            transform_file_var RABBIT_HOST
            if [ -n "${RABBIT_HOST}" ]; then
                rabbit_host=${RABBIT_HOST}
            fi
            rabbit_host=${rabbit_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until RabbitMQ server becomes accessible
            while ! (nc -z "${rabbit_host}" "${rabbit_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "RabbitMQ Host '${rabbit_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        "redis" )
            # Resolve port configurations
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                redis_port=${DB_PORT}
            fi
            if [ -n "${REDIS_PORT}" ]; then
                redis_port=${REDIS_PORT}
            fi
            redis_port=${redis_port:-6379}

            # Resolve host configurations
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                redis_host=${DB_HOST}
            fi
            if [ -n "${REDIS_HOST}" ]; then
                redis_host=${REDIS_HOST}
            fi
            redis_host=${redis_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until Redis server becomes accessible
            while ! (nc -z "${redis_host}" "${redis_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "Redis Host '${redis_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        "rethink" )
            # Resolve port configurations
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ]; then
                rethink_port=${DB_PORT}
            fi
            if [ -n "${RETHINK_PORT}" ]; then
                rethink_port=${RETHINK_PORT}
            fi
            rethink_port=${rethink_port:-28015}

            # Resolve host configurations
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ]; then
                rethink_host=${DB_HOST}
            fi
            if [ -n "${RETHINK_HOST}" ]; then
                rethink_host=${RETHINK_HOST}
            fi
            rethink_host=${rethink_host:-"localhost"}

            # Initialize retry counter
            counter=0

            # Retry until RethinkDB server becomes accessible
            while ! (nc -z "${rethink_host}" "${rethink_port}"); do
                sleep 5
                (( counter+=5 ))
                print_warn "RethinkDB Host '${rethink_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        *)
            # Unsupported database type
            print_error "Unsupported database type: $1"
            exit 1
        ;;
    esac

    # Re-enable output after the check
    output_on
}

## Function: Checks if a directory is empty
## Usage:
## - dir_empty <directory_path>
## - Returns 0 (true) if the directory is empty, 1 (false) otherwise.
dir_empty() {
    [ ! -n "$(ls -A "$1" 2>/dev/null)" ]
}

## Function: Checks if a directory is not empty
## Usage:
## - dir_notempty <directory_path>
## - Returns 0 (true) if the directory contains files, 1 (false) otherwise.
dir_notempty() {
    [ -n "$(ls -A "$1" 2>/dev/null)" ]
}

## Function: Loads a variable from a file or directly from the environment
## Usage:
## - file_env VAR [DEFAULT]
##   Example: file_env 'XYZ_DB_PASSWORD' 'example'
## Notes:
## - If Docker secrets are enabled, this function supports loading values securely.
## - Allows the value of `VAR` to be set from a file specified by `VAR_FILE`.
## - If both `VAR` and `VAR_FILE` are unset, an error is raised, and the script exits.
## - Ensures compatibility with Docker's secrets feature for secure configuration management.
file_env() {
    # Ensure Docker secrets are enabled before processing
    if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" = "true" ]; then
        local var="$1"              # Variable name
        local fileVar="${var}_FILE" # Corresponding file variable name (e.g., VAR_FILE)
        local def="${2:-}"          # Default value if no variable or file is set
        local val="$def"            # Initial value to be exported

        # Check if the file variable is set and read its contents
        if [ "${!fileVar:-}" ]; then
            if [ -f "${!fileVar}" ]; then
                val="$(cat "${!fileVar}")"
            else
                # Error if the file does not exist or is not readable
                print_error "error: file '${!fileVar}' specified in ${fileVar} does not exist or is not readable"
                exit 1
            fi
        elif [ "${!var:-}" ]; then
            # Use the value of the environment variable if set
            val="${!var}"
        fi

        # Ensure a valid value is set, either from the file or the environment variable
        if [ -z "${val}" ]; then
            print_error "error: neither $var nor $fileVar are set but are required"
            exit 1
        fi

        # Export the final value and unset the file variable to avoid conflicts
        export "$var"="$val"
        unset "$fileVar"
    fi
}

## Function: Loads default configurations based on the specified scope
## Usage:
## - get_defaults [scope]
##   - Scope options:
##     - "all": Loads all configuration files in `/assets/defaults/`.
##     - "app" or "single": Loads the default configuration for the current script or working directory.
##     - <comma-separated list>: Loads specific files by name.
## - If no scope is provided, defaults to loading all files.
## Notes:
## - Handles special cases for files starting with "0*" or "99*".
## - Provides debug output for tracing loaded defaults.
get_defaults() {
    if [ -n "$1" ]; then
        case "${1,,}" in
            "all" )
                # Load all default configuration files
                for d in /assets/defaults/*; do
                    print_debug "Container: Loading defaults for '${d}' (ALL)"
                    # Handle special case files starting with "0*" or "99*"
                    case "$(basename "${d}")" in
                        0*-* | 99-* )
                            output_off
                            source "${d}"
                            output_on
                        ;;
                        * )
                            source "${d}"
                        ;;
                    esac
                done
            ;;
            "app" | "single" )
                # Load default configuration for the current script or directory
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                        # Handle defaults for the current script
                        if [ -f "/assets/defaults/$(basename "$0")" ]; then
                            print_debug "Container: Loading defaults for '$(basename "$0")'"
                            case "$(basename "$0")" in
                                0*-* | 99-* )
                                    output_off
                                    source /assets/defaults/"$(basename "$0")"
                                    output_on
                                ;;
                                * )
                                    source /assets/defaults/"$(basename "$0")"
                                ;;
                            esac
                        else
                            print_debug "Container: No defaults available for '$(basename "$0")'"
                        fi
                    ;;
                    * )
                        # Handle defaults for the current directory
                        if [ -f "/assets/defaults/$(basename "$PWD")" ]; then
                            print_debug "Container: Loading defaults for '$(basename "$PWD")'"
                            case "$(basename "$PWD")" in
                                0*-* | 99-* )
                                    output_off
                                    source /assets/defaults/"$(basename "$PWD")"
                                    output_on
                                ;;
                                * )
                                    source /assets/defaults/"$(basename "$PWD")"
                                ;;
                            esac
                        else
                            print_debug "Container: No defaults available for '$(basename "$PWD")'"
                        fi
                    ;;
                esac
            ;;
            * )
                # Load specific configuration files based on a comma-separated list
                defaults=$(echo "$1" | tr "," "\n")
                for d in $defaults; do
                    if [ -f "/assets/defaults/${d}" ]; then
                        print_debug "Container: Loading defaults for '${d}'"
                        case "${d}" in
                            0*-* | 99-* )
                                output_off
                                source /assets/defaults/"${d}"
                                output_on
                            ;;
                            * )
                                source /assets/defaults/"${d}"
                            ;;
                        esac
                    else
                        print_debug "Container: No defaults available for '${d}'"
                    fi
                done
            ;;
        esac
    else
        # Load all default configuration files if no scope is provided
        for d in /assets/defaults/*; do
            print_debug "Container: Loading defaults for '${d}' (NO SCOPE)"
            case "$(basename "${d}")" in
                0*-* | 99-* )
                    output_off
                    source /assets/defaults/00-container
                    source "${d}"
                    output_on
                ;;
                * )
                    source /assets/defaults/00-container
                    source "${d}"
                ;;
            esac
        done
    fi
}

## Function: Loads custom functions based on the specified scope
## Usage:
## - get_functions [scope]
##   - "all": Loads all function files except `00-container`.
##   - "app" or "single": Loads the function file for the current script or directory.
##   - <comma-separated list>: Loads specific function files by name.
## - If no scope is provided, defaults to loading all function files.
## Notes:
## - Provides debug output for tracing loaded functions.
get_functions() {
    # Check if a specific scope is provided
    if [ -n "$1" ]; then
        case "${1,,}" in
            "all" )
                # Load all function files except `00-container`
                for f in /assets/functions/*; do
                    if [ "$f" != "/assets/functions/00-container" ]; then
                        print_debug "Container: Loading functions for '${f}'"
                        source "$f"
                    fi
                done
            ;;
            "app" | "single" )
                # Load the function file for the current script or directory
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                        # Current script context
                        if [ -f "/assets/functions/$(basename "$0")" ]; then
                            print_debug "Container: Loading functions for '$(basename "$0")'"
                            source /assets/functions/"$(basename "$0")"
                        else
                            print_debug "Container: No functions available for '$(basename "$0")'"
                        fi
                    ;;
                    *)
                        # Current working directory context
                        if [ -f "/assets/functions/$(basename "$PWD")" ]; then
                            print_debug "Container: Loading functions for '$(basename "$PWD")'"
                            source /assets/functions/"$(basename "$PWD")"
                        else
                            print_debug "Container: No functions available for '$(basename "$PWD")'"
                        fi
                    ;;
                esac
            ;;
            * )
                # Load specific function files by name
                functions=$(echo "$1" | tr "," "\n")
                for f in $functions; do
                    if [ -f "/assets/functions/${f}" ]; then
                        print_debug "Container: Loading functions for '${f}'"
                        source /assets/functions/"${f}"
                    else
                        print_debug "Container: No functions available for '${f}'"
                    fi
                done
            ;;
        esac
    else
        # Load all function files if no scope is provided
        for f in /assets/functions/*; do
            if [ "$f" != "/assets/functions/00-container" ]; then
                print_debug "Container: Loading functions for '${f}'"
                source "${f}"
            fi
        done
    fi
}

## Function: Retrieves the image version from changelog files
## Usage:
## - get_image_version
## Notes:
## - Reads the image version from various `.md` changelog files.
## - Supports multiple file naming conventions for changelogs.
## - Outputs the image version if found, or remains silent otherwise.
get_image_version() {
    # Disable output during version retrieval to reduce noise
    output_off

    # Check if IMAGE_NAME is defined
    if [ -n "${IMAGE_NAME}" ]; then
        # Attempt to read the version from a changelog file matching IMAGE_NAME
        if [ -f "/assets/.changelogs/${IMAGE_NAME//\//_}.md" ]; then
            # Extract the version from the first line of the changelog
            image_version=$(head -n1 /assets/.changelogs/${IMAGE_NAME//\//_}.md | awk '{print $2}')
        elif [ -f /assets/.changelogs/docker-${IMAGE_NAME//\//_}.md ]; then
            # Check for a docker-specific changelog file
            image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME//\//_}.md | awk '{print $2}')
        else
            # Check for a `focela_docker` naming convention in changelog files
            if [ -f /assets/.changelogs/focela_docker-${IMAGE_NAME//\//_}.md ]; then
                image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME//\//_}.md | awk '{print $2}')
            else
                # Try stripping the repository URL and check for a matching changelog file
                strip_image_repo_url=$(echo ${IMAGE_REPO_URL%/} | sed "s#https://github.com/##g")
                if [ -f /assets/.changelogs/${strip_image_repo_url//\//_}.md ]; then
                    image_version=$(head -n1 /assets/.changelogs/${strip_image_repo_url//\//_}.md | awk '{print $2}')
                fi
            fi

            # Additional check for `focela_docker` convention as fallback
            if [ -f /assets/.changelogs/focela_docker-${IMAGE_NAME//\//_}.md ]; then
                image_version=$(head -n1 /assets/.changelogs/focela_docker-${IMAGE_NAME//\//_}.md | awk '{print $2}')
            fi
        fi

        # Output the image version if it was successfully extracted
        if [ -n "${image_version}" ]; then
            echo "${image_version}"
        fi
    fi

    # Re-enable output after the version retrieval process
    output_on
}

## Function: Grants "doas" privileges to a user
## Usage:
## - grant_doas <username> [command]
##   - If no command is specified, the user gets access to all commands.
## Notes:
## - Appends the configuration to `/etc/doas.conf`.
## - Ensures the configuration file has appropriate permissions.
grant_doas() {
    ## Disable output to reduce noise during execution
    output_off

    ## Check if the username argument is provided
    if [ -n "$1" ]; then
        print_debug "Adding Doas privileges to '$1'"

        ## Handle optional command argument
        if [ -n "$2" ]; then
            doas_command="cmd $2"
            print_debug "Adding Doas privileges to '$1' for command '$2'"
        else
            doas_command=""
        fi

        ## Append privilege rule to the configuration file
        echo "permit nopass $1 ${doas_command} as root" >> /etc/doas.conf

        ## Set ownership and secure permissions for the configuration file
        chown root:root /etc/doas.conf
        chmod 0400 -R /etc/doas.conf
    fi

    ## Re-enable output after execution
    output_on
}

## Function: Grants "sudo" privileges to a user
## Usage:
## - grant_sudo <username> [command]
##   - If no command is specified, grants access to all commands.
## Notes:
## - Appends configuration to `/etc/sudoers`.
## - Marks this function as deprecated and suggests using `grant_doas` instead.
grant_sudo() {
    # Disable output during execution
    output_off

    # Ensure username is provided
    if [ -n "$1" ]; then
        # Determine the command or default to "ALL"
        if [ -n "$2" ]; then
            sudo_command="$2"
        else
            sudo_command="ALL"
        fi

        # Debug message for tracking privilege assignment
        print_debug "Adding Sudo privileges to '$1' for '${sudo_command}' command"

        # Append the privilege rule to /etc/sudoers
        echo "%$1 ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers

        # Ensure the sudoers file remains valid
        if ! visudo -cf /etc/sudoers &>/dev/null; then
            print_error "Invalid sudoers file. Reverting changes."
            sed -i "/%$1 ALL=(ALL) NOPASSWD:${sudo_command}/d" /etc/sudoers
            exit 1
        fi
    fi

    # Re-enable output after execution
    output_on
}

## Function: Adds custom entries to /etc/hosts
## Usage:
## - Define environment variables as CONTAINER_HOST_OVERRIDE_<number>=<destination_ip> <domain1> <domain2> ...
## - Example:
##   CONTAINER_HOST_OVERRIDE_01="192.168.1.1 example.com example.org"
##   CONTAINER_HOST_OVERRIDE_02="host.example.net app.local"
## Notes:
## - Resolves `destination_ip` to an IP address if it is a hostname.
## - Appends entries to `/etc/hosts` with comments for traceability.
host_override() {
    # Count the number of defined CONTAINER_HOST_OVERRIDE variables
    _hostnum=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9]+)')

    # Iterate over each CONTAINER_HOST_OVERRIDE_<number> variable
    for (( _host = 1; _host <= _hostnum; _host++ )); do
        # Format the number to two digits
        _host=$(printf "%02d" "$_host")

        # Retrieve the value of the current host override variable
        host_line=CONTAINER_HOST_OVERRIDE_${_host}
        host_entry=${!host_line}

        # Extract the destination IP or hostname from the variable
        host_ip=$(echo "$host_entry" | awk '{print $1}')

        # Resolve hostname to an IP address if necessary
        if [[ ! "$host_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            host_ip=$(getent ahostsv4 "$host_ip" | grep -m 1 STREAM | awk '{print $1}')
            if [ -z "$host_ip" ]; then
                print_warn "Failed to resolve hostname '${host_entry}' to an IP address."
                continue
            fi
        fi

        # Extract the list of domains associated with the IP
        host_domains=$(echo "$host_entry" | cut -d' ' -f2-)

        # Append the entry to /etc/hosts with a comment for traceability
        echo "# Added automatically by CONTAINER_HOST_OVERRIDE_${_host}" >> /etc/hosts
        echo "${host_ip} ${host_domains}" >> /etc/hosts

        # Print debug information about the added entry
        print_debug "Added to /etc/hosts: ${host_ip} ${host_domains}"
    done
}

## Installs a template file to a target location with specific ownership and permissions
## Usage:
## - install_template <owner:group> <template_source> <destination> [permissions]
## Notes:
## - Creates the destination directory if it does not exist.
## - Ensures appropriate permissions and ownership for the installed file.
install_template() {
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]; then
        print_error "[install_template] Missing required arguments. Usage: install_template <owner:group> <template_source> <destination> [permissions]"
        exit 1
    fi

    local template_mode=${4:-"0644"}

    if [ ! -f "$2" ]; then
        print_error "[install_template] Source file '${2}' not found."
        exit 1
    fi

    if [ ! -d "$(dirname "$3")" ]; then
        mkdir -p "$(dirname "$3")" # Create destination directory if it doesn't exist
    fi

    cp "$2" "$3"

    chown "$1" "$3"
    chmod "${template_mode}" "$3"
}

## Function: Generates a log prefix based on configured formats
## Usage:
## - log_prefix
## Notes:
## - Adds a prefix to log messages if log prefixing is enabled.
## - Combines date, time, and separator formats as defined in configuration.
log_prefix() {
    # Disable console output during execution
    output_off

    # Check if log prefixing is enabled
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
        # Generate log prefix using configured date and time formats
        echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
    fi

    # Re-enable console output after execution
    output_on
}

## Function: Handles the initialization state of scripts
## Usage:
## - liftoff
## Notes:
## - Writes the script or working directory initialization state to `/tmp/.container`.
## - Includes timestamps for initialization or reinitialization events.
## - Supports a `DONOTSTART` prefix for scripts that should not start.
liftoff() {
    # Disable console output during initialization
    output_off

    # Ensure the container state directory exists
    mkdir -p /tmp/.container

    # Add a prefix for scripts marked with DONOTSTART
    if [ "$DONOTSTART" = "TRUE" ]; then
        liftoff_prefix="DONOTSTART "
    fi

    # Handle initialization based on script execution context
    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            # For scripts in the initialization directories, log as initialized
            echo "${liftoff_prefix}$(basename "$0")-init initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$0")"-init
        ;;
        *)
            # For other contexts, check if reinitialization is required
            if [ ! -f /tmp/.container/"$(basename "$PWD")" ]; then
                echo "$(basename "$PWD") initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            else
                echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            fi
        ;;
    esac

    # Re-enable console output after initialization
    output_on
}

## Function: Disables verbose output to reduce noise in log files
## Usage:
## - output_off
## Notes:
## - Primarily used to suppress unnecessary logs, especially echo statements.
## - Respects the `DEBUG_MODE` environment variable for conditional behavior.
output_off() {
    # Check if debug mode is enabled
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        # Disable verbose output to suppress logs
        set +x
    fi
}

## Function: Enables verbose output to aid debugging
## Usage:
## - output_on
## Notes:
## - Re-enables verbose output if `DEBUG_MODE` is set to "true".
## - Handles special cases for specific script names or directories.
output_on() {
    # Check if debug mode is enabled
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        # Determine behavior based on script name or directory context
        case "$(basename "$0")" in
            0*-* | 99-* )
                # Skip verbose output for scripts matching special patterns
                :
            ;;
            run )
                # Additional checks for scripts in the "run" context
                case "$PWD" in
                    */0*-* | 99-* )
                        # Skip verbose output for directories matching special patterns
                        :
                    ;;
                    * )
                        # Enable verbose output for other directories
                        set -x
                    ;;
                esac
            ;;
            * )
                # Enable verbose output for all other cases
                set -x
            ;;
        esac
    fi
}

## Function: Manages package operations for the container
## Usage:
## - package <action> [arguments...]
## Actions:
## - install: Installs packages based on the distro.
## - remove: Removes packages, with optional cleanup for specific distros.
## - update: Updates package indexes.
## - upgrade: Upgrades installed packages.
## - cleanup: Cleans up cache and temporary files.
## Notes:
## - Supports Alpine, Debian, and Ubuntu distributions.
## - Automatically detects the distribution from `/etc/os-release`.
package() {
    # Cleans up temporary files and caches after package operations
    cleanup() {
        case "${distro}" in
            "alpine" )
                rm -rf /root/.gitconfig
                rm -rf /var/cache/apk/*
            ;;
            "debian" | "ubuntu" )
                apt-get clean -y
                rm -rf /root/.gitconfig
                rm -rf /var/lib/apt/lists/*
            ;;
        esac
    }

    # Installs packages based on the detected distribution
    install() {
        case "${distro}" in
            "alpine" )
                if [[ "${1}" =~ ^\..* ]]; then
                    local dependencies="-t"
                fi
                apk add ${dependencies} "${@}"
            ;;
            "debian" | "ubuntu" )
                if [[ "${1}" =~ ^\..* ]]; then
                    shift
                fi
                apt-get install -y --no-install-recommends "${@}"
            ;;
        esac
    }

    # Removes packages based on the detected distribution
    remove() {
        case "${distro}" in
            "alpine" )
                apk del "${@}"
            ;;
            "debian" | "ubuntu" )
                local packages="${@}"
                if [[ "${packages}" =~ \..* ]]; then
                    packages=$(echo "${packages}" | sed "s|\..* ||g")
                fi
                apt-get purge -y ${packages}
                apt-get autoremove -y
            ;;
        esac
    }

    # Updates package indexes
    update() {
        case "${distro}" in
            "alpine" )
                apk update
            ;;
            "debian" | "ubuntu" )
                apt-get update
            ;;
        esac
    }

    # Upgrades installed packages
    upgrade() {
        case "${distro}" in
            "alpine" )
                apk upgrade
            ;;
            "debian" | "ubuntu" )
                apt-get upgrade -y
            ;;
        esac
    }

    # Disable verbose output during package operations
    output_off

    # Detect the distribution from `/etc/os-release`
    local distro
    distro=$(cat /etc/os-release | grep ^ID= | cut -d = -f2)

    # Determine the requested action and corresponding arguments
    local action="${1}"
    shift
    local arguments="${@}"

    # Route actions to the appropriate function
    case "${action}" in
        add | install )
            action=install
            "${action}" "${arguments}"
        ;;
        delete | remove | uninstall )
            action=remove
            "${action}" "${arguments}"
        ;;
        * )
            "${action}" "${arguments}"
        ;;
    esac

    # Re-enable verbose output after package operations
    output_on
}

## Function: Prepares the service environment by loading defaults and functions
## Usage:
## - prepare_service [BOTH|DEFAULTS|FUNCTIONS] [optional arguments]
## Notes:
## - Calls `get_defaults` and `get_functions` based on context and options.
## - Automatically detects if running in `cont-init.d` or outside.
prepare_service() {
    ## Check if an option is provided
    if [ -n "$1" ] ; then
        ## Determine execution context based on the script directory
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                ## Initialization context: Load defaults and functions with all variables exported
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
            ;;
            *)
                ## Non-initialization context: Handle specific options for defaults/functions
                case "$1" in
                    "BOTH" | "both" | "ALL" | "all" )
                        get_defaults "$2"
                        get_functions "$2"
                    ;;
                    "DEFAULTS" | "defaults" )
                        get_defaults "$2"
                    ;;
                    "FUNCTIONS" | "functions" )
                        get_functions "$2"
                    ;;
                esac
            ;;
        esac
    else
        ## Default behavior when no options are provided
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
            ;;
            *)
                get_defaults
            ;;
        esac
    fi
}

## Function: Logs debug-level messages with optional color and file output
## Usage:
## - print_debug <message>
## Notes:
## - Uses `CONTAINER_LOG_LEVEL` and `CONTAINER_LOG_FILE_LEVEL` to determine verbosity.
## - Supports colorized output and file logging based on environment variables.
print_debug() {
    # Temporarily disable verbose output
    output_off

    # Determine log behavior based on CONTAINER_LOG_LEVEL
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" )
            if [ "${DEBUG_MODE,,}" = "true" ]; then
                # Debug mode active with optional colorization
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                # Non-debug mode with optional colorization
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    # Handle file logging based on CONTAINER_LOG_FILE_LEVEL
    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" )
            echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac

    # Re-enable verbose output
    output_on
}

## Function: Logs error-level messages with optional color and file output
## Usage:
## - print_error <message>
## Notes:
## - Logs error messages to both console and file based on environment variables.
## - Supports colorized output for better visibility when enabled.
## - Handles script and process-specific context with timestamps using `log_prefix`.
print_error() {
    # Temporarily disable verbose output
    output_off

    # Handle console logging based on CONTAINER_LOG_LEVEL
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" | "warn" | "error")
            # Check if DEBUG_MODE is enabled
            if [ "${DEBUG_MODE,,}" = "true" ]; then
                # Log with or without colorization based on settings
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    # Handle file logging based on CONTAINER_LOG_FILE_LEVEL
    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" | "warn" | "error")
            echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac

    # Re-enable verbose output
    output_on
}

## Function: Logs informational messages to console and file
## Usage:
## - print_info <message>
## Notes:
## - Supports colorized and non-colorized output based on `CONTAINER_COLORIZE_OUTPUT`.
## - Logs messages to both console and a log file (`CONTAINER_LOG_FILE_PATH`).
## - Includes context-specific details like script name, process name, and timestamps.
print_info() {
    # Temporarily disable verbose output
    output_off

    # Determine logging behavior based on DEBUG_MODE and CONTAINER_COLORIZE_OUTPUT
    if [ "${DEBUG_MODE,,}" = "true" ]; then
        # Log with or without colorization for debug mode
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
    else
        # Log with or without colorization for non-debug mode
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
            echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
        fi
    fi

    # Append the log message to the log file
    echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"

    # Re-enable verbose output
    output_on
}

## Function: Logs notice-level messages to console and file
## Usage:
## - print_notice <message>
## Notes:
## - Logs "notice" level messages to console and a log file (`CONTAINER_LOG_FILE_PATH`).
## - Supports colorized or non-colorized output based on `CONTAINER_COLORIZE_OUTPUT`.
## - Respects verbosity settings defined by `CONTAINER_LOG_LEVEL` and `CONTAINER_LOG_FILE_LEVEL`.
print_notice() {
    # Temporarily disable verbose output
    output_off

    # Handle console logging based on CONTAINER_LOG_LEVEL
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" )
            # Check if DEBUG_MODE is enabled
            if [ "${DEBUG_MODE,,}" = "true" ]; then
                # Log with or without colorization for debug mode
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                # Log with or without colorization for non-debug mode
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    # Handle file logging based on CONTAINER_LOG_FILE_LEVEL
    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" )
            echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac

    # Re-enable verbose output
    output_on
}

## Function: Manages the start process of a containerized service
## Usage:
## - print_start <message>
## Notes:
## - Handles process counters and protects against runaway processes.
## - Logs service start events to console and file with optional colorization.
## - Executes process helper scripts if configured.
print_start() {
    # Disable verbose output temporarily
    output_off

    # Process counter logic
    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ] ; then
        # Check if process counter file exists and calculate count
        if [ -f /tmp/.container/"$(basename $PWD)" ]; then
            proc_start_count=$(cat /tmp/.container/"$(basename $PWD)" | wc -l)
            proc_start_wrapper="[${proc_start_count}] "
        fi

        # Initialize process counter if not already set
        if [ -z "${proc_start_count}" ] ; then proc_start_count=1 ; fi

        # Prepare arguments for the process helper script
        proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$(pwd)") ${proc_start_count} $(cat /etc/hostname)"

        # Check if a process helper script exists and execute it
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh "${proc_help_arg}"
            elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh ] ; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh "${proc_help_arg}"
            fi
        fi

        # Runaway process protection
        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ] ; then
            # Show final output if process count hits the limit
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ] ; then
                if [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ] ; then SHOW_OUTPUT=TRUE ; fi
            fi

            # Disable service if process count exceeds limit
            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ] ; then
                print_error "POTENTIAL RUNWAY DETECTED: Disabling $(basename $PWD) service because it has tried restarting '${CONTAINER_PROCESS_RUNAWAY_LIMIT}' times"
                s6-svc -d /var/run/s6/legacy-services/$(basename "$PWD")
                sleep 3
                exit 1
            fi

            # Log and apply a delay between restarts
            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ] ; then sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}" ; fi
        fi
    fi

    # Log starting message based on DEBUG_MODE and colorization settings
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    fi

    # Re-enable verbose output
    output_on
}

## Function: Logs warning-level messages to console and file
## Usage:
## - print_warn <message>
## Notes:
## - Supports colorized and non-colorized output based on environment variables.
## - Logs messages to console and file depending on `CONTAINER_LOG_LEVEL` and `CONTAINER_LOG_FILE_LEVEL`.
print_warn() {
    # Temporarily disable verbose output
    output_off

    # Log warning message to console based on log level and color settings
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" | "warn" )
            log_message="[WARN] ** [${PROCESS_NAME}] $1"
            if [ "${DEBUG_MODE,,}" = "true" ]; then
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)${log_message}"
                else
                    echo -e "$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
                    echo -e "$(log_prefix)${log_message}"
                else
                    echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    # Append warning message to log file based on file log level
    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" | "warn" )
            echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac

    # Re-enable verbose output
    output_on
}
