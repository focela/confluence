#!/command/with-contenv bash

# Load default container configuration
source /assets/defaults/00-container

# Background Colors Configuration
bdg="\e[42m"       # Background color: Dark Green
bdb="\e[44m"       # Background color: Dark Blue
bdm="\e[45m"       # Background color: Dark Magenta
bdgy="\e[100m"     # Background color: Dark Gray
blr="\e[101m"      # Background color: Light Red
boff="\e[49m"      # Reset background color to default

# Check if container initialization scripts have completed
check_container_initialized() {
    # Print a debug message to indicate initialization check
    print_debug "Checking if container initialization scripts have completed"

    # Disable output during the waiting process
    output_off

    # Wait until the initialization flag file is present
    while [ ! -f /tmp/.container/99-container-init ]; do
        # Continuously print debug messages for visibility
        print_debug "Container initialization in progress..."
        sleep 1  # Wait for 1 second before checking again
    done

    # Re-enable output after initialization is complete
    output_on
}

## Function: Checks if a service has been initialized
## Usage:
## - check_service_initialized init: Checks for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>-init.
## - check_service_initialized <service folder>: Checks for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>.
## Notes:
## - Related to the liftoff function, which writes /tmp/.container/script|foldername.
## - Scripts in /etc/cont-init.d add `-init` to their filename.
## - Scripts in /etc/services.available/* use the folder name directly without any suffix.
check_service_initialized() {
    # Print a debug message to indicate initialization check
    print_debug "Checking to see if service has initialized"

    # Disable output during the waiting process
    output_off

    # Determine service initialization behavior based on input arguments
    if [ "$1" = "init" ]; then
        # For scripts running in /etc/cont-init.d, append `-init` to the service name
        service_suffix="-init"
        csi_bypass=FALSE
    else
        # For services in /etc/services.available, use folder name directly
        service="$1"
        csi_bypass=TRUE
    fi

    # Resolve the service name if bypass is disabled
    if [ "$csi_bypass" = "FALSE" ]; then
        if [ -z "$2" ]; then
            # Determine service name based on the script's execution context
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    # Use the script name as the service name
                    service=$(basename "$0")
                ;;
                *)
                    # Use the current working directory as the service name
                    service=$(basename "$PWD")
                ;;
            esac
        else
            # Use the second argument as the service name
            service=$2
        fi
    fi

    # Wait until the service initialization flag file is present
    while [ ! -f /tmp/.container/"${service}${service_suffix}" ]; do
        # Wait for 1 second before checking again
        sleep 1
        # Print debug message to indicate the file being checked
        print_debug "Looking for existence of /tmp/.container/${service}${service_suffix}"
    done

    # Cleanup temporary variable
    unset csi_bypass

    # Re-enable output after initialization is complete
    output_on
}

## Function: Clones a Git repository with optional branch, tag, or commit
## Usage:
## - clone_git_repo <repo_url> <branch/tag/commit> <custom_dest>
## - Example: clone_git_repo https://github.com/maintainer/repo main /custom/destination
## Notes:
## - Automatically creates a folder in `/usr/src/<repo_name>` if no custom destination is provided.
## - Exposes environment variables `GIT_REPO_SRC` and `GIT_REPO_SRC_<REPONAME>` (uppercase).
## - Removes special characters except numbers and letters in the repository name.
clone_git_repo() {
    # Temporarily disable debug output
    set +x
    if [ "${DEBUG_MODE,,}" = "true" ]; then set -x; fi  # Enable debug mode if set

    # Check if Git is installed
    if ! [ -x "$(command -v git)" ]; then
        echo '[clone_git_repo] Git is not installed'
        exit 1
    else
        git config --global init.defaultBranch main  # Set default branch to "main"
    fi

    # Validate repository URL and parameters
    if [ -n "$1" ]; then
        # Define repository path and name based on input
        if [ -n "${3}" ]; then
            repo="${3}/"
            repo_text="to '${3}'"
            repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        else
            repo="/usr/src/$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
            repo_name="$(echo "${1,,}" | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        # Export environment variables for the repository
        export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repo}"}
        export GIT_REPO_SRC_${repo_name^^}="${repo}"

        # Check if the directory already exists
        if [ -d "${repo}" ]; then
            echo "[clone_git_repo] Directory ${repo_path}${repo} already exists. Cannot clone."
            exit 1
        else
            # Append ".git" suffix if missing
            if [[ $1 == *".git" ]]; then
                append_git_prefix=""
            else
                append_git_prefix=".git"
            fi

            # Create directory, initialize, and clone the repository
            mkdir -p "${repo}"
            cd "${repo}"
            git init .
            git remote add origin "${1}${append_git_prefix}"

            # Fetch and checkout specific branch/tag/commit if provided
            if [ -n "${2}" ]; then
                repo_commit="${2}"
            fi
            echo "[clone_git_repo] Cloning Git Repo '${1}' '${2}' ${repo_text}"
            git fetch --depth=1 origin ${2} +refs/tags/*:refs/tags/*
            git fetch --depth 1 origin ${2}
            git -c advice.detachedHead=false checkout FETCH_HEAD
            git submodule update --init
        fi
    else
        # Print an error if no arguments are provided
        echo "[clone_git_repo] You tried to call the function but there's no arguments."
        exit 1
    fi

    # Re-enable debug output
    set -x
}
